# AUTOGENERATED! DO NOT EDIT! File to edit: . (unless otherwise specified).

__all__ = ['CHIRAL_DICT', 'HYBRIDIZATION', 'EDGE_FEATURES', 'ELEMENTS', 'onek_encoding_unk', 'MolecularGraph',
           'MolecularDataset', 'save_df', 'MolecularGraphDataset']

# Cell
import scipy as sp

from rdkit import Chem
from rdkit.Chem import AllChem
from functools import partial
import pandas as pd
import numpy as np

import torch
from torch import nn

import multiprocessing as mp
from tqdm import tqdm
from datetime import datetime

from fastai.tabular.all import *
from sklearn.utils.multiclass import type_of_target
from sklearn.utils.multiclass import unique_labels


# Cell
CHIRAL_DICT = {Chem.ChiralType.CHI_UNSPECIFIED:0,
Chem.ChiralType.CHI_TETRAHEDRAL_CW:1,
Chem.ChiralType.CHI_TETRAHEDRAL_CCW:2,
Chem.ChiralType.CHI_OTHER:3}

HYBRIDIZATION = {Chem.rdchem.HybridizationType.UNSPECIFIED: 0,
 Chem.rdchem.HybridizationType.S: 1,
 Chem.rdchem.HybridizationType.SP: 2,
 Chem.rdchem.HybridizationType.SP2: 3,
 Chem.rdchem.HybridizationType.SP3: 4,
 Chem.rdchem.HybridizationType.SP3D: 5,
 Chem.rdchem.HybridizationType.SP3D2: 6,
 Chem.rdchem.HybridizationType.OTHER: 7}

EDGE_FEATURES = {
    Chem.rdchem.BondType.SINGLE: 0,
    Chem.rdchem.BondType.DOUBLE: 1,
    Chem.rdchem.BondType.TRIPLE: 2,
    Chem.rdchem.BondType.AROMATIC: 3,
}
ELEMENTS = list(range(100))

# Cell
def onek_encoding_unk(value: int, choices):
    """
    Creates a one-hot encoding with an extra category for uncommon values.
    :param value: The value for which the encoding should be one.
    :param choices: A list of possible values.
    :return: A one-hot encoding of the :code:`value` in a list of length :code:`len(choices) + 1`.
             If :code:`value` is not in :code:`choices`, then the final element in the encoding is 1.
    """
    encoding = [0] * (len(choices) + 1)
    index = choices.index(value) if value in choices else -1
    encoding[index] = 1

    return torch.tensor(encoding).view(1,-1).float()

# Cell
class MolecularGraph:
    """
    Parent class for Molecular graphs

    Converts a Chem.Mol object into a molecular graph representation


    Arguments:
    -----------------------------------------------------------------

        smiles : str
            A SMILES representing a molecular structure


     Attributes:
    -----------------------------------------------------------------

        mol : Chem.Mol
            `Chem.Mol` object generated from `smiles`

        n_nodes : int
            Number of atoms (nodes) in the graph

        n_edges : int
            Number of bonds (edges) in the graph

        node_features : numpy.array
            An array with node features

        edge_features : numpy.array
            An array with edge features

    """

    def __init__(self, smiles:str, target:np.array):

        # Atom feature sizes
        self.MAX_ATOMIC_NUM = 100
        self.ATOM_FEATURES = {
            'atomic_num': list(range(self.MAX_ATOMIC_NUM)),
            'degree': [0, 1, 2, 3, 4, 5],
            'formal_charge': [-3, -2, -1, 0, 1, 2, 3],
            'chiral_tag': [0, 1, 2, 3],
            'num_Hs': [0, 1, 2, 3, 4],
            'hybridization': [
                Chem.rdchem.HybridizationType.SP,
                Chem.rdchem.HybridizationType.SP2,
                Chem.rdchem.HybridizationType.SP3,
                Chem.rdchem.HybridizationType.SP3D,
                Chem.rdchem.HybridizationType.SP3D2
            ],
        }

        self.smiles = smiles
        self.y = torch.tensor(np.array(target,dtype=np.float32))#.view(-1,1)
        self.mol = Chem.MolFromSmiles(smiles)
        self.n_nodes = None
        self.n_edges = None
        self.node_features = None
        self.edge_features = None
        self.N_EDGE_FEATURES = 14
        self.N_NODE_FEATURES = sum(len(choices) + 1 for choices in self.ATOM_FEATURES.values()) + 2

    def atom_features(self, atom:Chem.rdchem.Atom):
        # Get node features
        node_features = [onek_encoding_unk(atom.GetAtomicNum() - 1, self.ATOM_FEATURES['atomic_num']),
        onek_encoding_unk(atom.GetTotalDegree(), self.ATOM_FEATURES['degree']),
        onek_encoding_unk(atom.GetFormalCharge(), self.ATOM_FEATURES['formal_charge']),
        onek_encoding_unk(int(atom.GetChiralTag()), self.ATOM_FEATURES['chiral_tag']),
        onek_encoding_unk(int(atom.GetTotalNumHs()), self.ATOM_FEATURES['num_Hs']),
        onek_encoding_unk(int(atom.GetHybridization()), self.ATOM_FEATURES['hybridization']),
        torch.tensor([1 if atom.GetIsAromatic() else 0]).view(1,-1),
        torch.tensor([atom.GetMass()*0.01]).view(1,-1)] # scaled to about the same range as other features
        return torch.cat(node_features,-1)



    def bond_features(self, bond: Chem.rdchem.Bond):
        """
        Builds a feature vector for a bond.
        :param bond: An RDKit bond.
        :return: A list containing the bond features.
        """

        if bond is None:
            fbond = [1] + [0] * (self.BOND_FDIM - 1) #
        else:
            bt = bond.GetBondType()
            fbond = [
                0,  # bond is not None
                bt == Chem.rdchem.BondType.SINGLE,
                bt == Chem.rdchem.BondType.DOUBLE,
                bt == Chem.rdchem.BondType.TRIPLE,
                bt == Chem.rdchem.BondType.AROMATIC,
                (bond.GetIsConjugated() if bt is not None else 0),
                (bond.IsInRing() if bt is not None else 0)
            ]
            stereo_info = onek_encoding_unk(int(bond.GetStereo()), list(range(6)))
        return torch.cat((torch.tensor(fbond).view(1,-1),stereo_info),-1)

    def mol_to_graph(self, max_nodes=None):
        """
        Generates the graph representation (`self.node_features` and
        `self.edge_features`) when creating a new `PreprocessingGraph`.
        """

        self.n_nodes = self.mol.GetNumAtoms() if max_nodes is None else max_nodes
        self.n_edges = self.mol.GetNumBonds()


        node_features = torch.zeros((self.n_nodes, self.N_NODE_FEATURES))
        edge_features = torch.zeros((self.n_nodes, self.n_nodes, len(EDGE_FEATURES.keys())))

        for idx, atom in enumerate(self.mol.GetAtoms()):
            node_features[idx] = self.atom_features(atom)


        for bonds in self.mol.GetBonds():
            i,j = bonds.GetBeginAtomIdx(),bonds.GetEndAtomIdx()
            bond_type = EDGE_FEATURES[self.mol.GetBondBetweenAtoms(i,j).GetBondType()]
            edge_features[i,j,bond_type] = 1
            edge_features[j,i,bond_type] = 1

        self.edge_features = edge_features
        self.node_features = node_features

        # Get adjacency matrix for each atom -> the adjancecy matrix is calculated by summing every atom row
        self.adjacency_matrix = torch.sum(edge_features,-1)
        self.adjacency_matrix_norm = self.adjacency_matrix  + torch.eye(self.adjacency_matrix .size()[1]) # Adjacency + identity matrix
        self.degree_matrix = torch.tensor(sp.linalg.fractional_matrix_power(torch.diag(torch.sum(self.adjacency_matrix_norm,-1)),-0.5))

        return self

# Cell
class MolecularDataset:

    """
    A generic class to handle tabular (e.g. dataframes) data for QSAR tasks.

    Parameters
    ------------------------------------------------------------------------------------------------------------

        df : DataFrame
            A `pandas.DataFrame` object with the data used for the modeling task.

        targets_col : str
            A string representing the column of `df` with the target variable.

        smiles_col : str
            A string representing the column of `df` with SMILES.


    Attributes
    ------------------------------------------------------------------------------------------------------------

        df : `DataFrame`
            A `pandas.DataFrame` object with the data used for the modeling task.

        cols : array-like
            An array of columns in `df`

        targets_col : str
            A string representing the column of `df` with the target variable.

        smiles_col : str
            A string representing the column of `df` with SMILES.

        smiles : array-like
            An array of SMILES of the molecules in `df`.

        y : array-like
            An array of target variable in `df`.

        data : array-like
            A n x p matrix with n SMILES and p y values.


    """

    def __init__(self,
                 df:pd.DataFrame,
                 smiles_col:str,
                 targets_col:str):

        self.df = df
        self.cols = df.columns
        self.smiles_col = smiles_col
        self.targets_col = targets_col
        self.smiles = df[smiles_col].values
        self._x = None
        self._y = df[targets_col].values
        self.data = df[[smiles_col, targets_col]].values


    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, i):
        self._x = i

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, i):
        self._y = i

    def copy(self):

        """Returns a copy of MolecularDataset"""

        return copy.deepcopy(self)

    def __len__(self):

        """Returns the size of MolecularDataset"""

        return len(self.data)

    def __getitem__(self, i):
        """

        Return a the i-th pair of (smiles, y) values

        """
        return self.data[i]

# Cell
def save_df(df, fname:str):
    """Save DataFrame to file"""
    df.to_csv(fname, index=False)

class MolecularGraphDataset(MolecularDataset):

    """
    Class to create a dataset for MolecularGraphDataset modeling.

    The factory methods from_df and from_csv can be used to directly load data from pandas DataFrames or CSV files.

    Instead use static methods `MolecularGraphDataset.from_df` or `MolecularGraphDataset.from_csv` for that purpose.

    Parameters
    ------------------------------------------------------------------------------------------------------------

        data : DataFrame

            A `pandas.DataFrame` object with the data used for the modeling task.

        targets_col : str

            A string representing the column of `data` with the target variable.

        smiles_col : str

            A string representing the column of `data` with SMILES.


    Attributes
    ------------------------------------------------------------------------------------------------------------

        data : MolecularDataset

            A MolecularDataset instance.

        x : array-like (n_samples, n_bits)

            An array with calculated descriptors for the processed dataset.

        y : array-like (n_samples, n_classes) or (n_samples, )

            An array with target variable values for each sample.

        train : MolecularDataset

            A MolecularDataset for the training set (defined with splitter).

        valid : MolecularDataset

            A MolecularDataset for the validation set (defaults to 20% of the data).

        splits : List[List, List]

            A list containing indices of samples belonging to training and validation sets.

        dtype : str

            A string representing the type of the target variable (`continuous`, `binary`, `multiclass`, `continuous-multioutput` or `multi-label indicatior`).


        jobtype : str

            Type of modeling task to perform based on `dtype`.

        timestamp : str

            A unique time identifier for the modeling task.

        save_dir : Path

            A `Path` object representing a folder where files and outputs will be saved.
    """

    def __init__(self, df: pd.DataFrame,smiles_col:str,targets_col:str,task_id:str=None):
        super().__init__(df,smiles_col,targets_col)

        self._x = None
        self._train = None
        self._valid = None
        self.task_id = task_id
        self._splits = None
        self.dtype = type_of_target(self.y)
        self.max_nodes = max(Chem.MolFromSmiles(m).GetNumAtoms() for m in self.smiles)
        self.job_type = TARGET2TYPE.get(self.dtype, None)
        self.save_dir = Path(f'{task_id}/{self.job_type}') if task_id else Path(f'GraphModel/{self.job_type}')

        # Create output folder
        Path(self.save_dir).mkdir(parents=True, exist_ok=True)

        if self.job_type in ['classification','multiclass']:
            self.classes = unique_labels(self.y)
            self.c = len(self.classes)

        self._timestamp = datetime.now()


    def copy(self):
        return copy.deepcopy(self)

    def __len__(self):
        return len(self.data)

    def __str__(self):
        return f'Time stamp: {self.timestamp}\nTarget: {self.targets_col}\nData type: {self.dtype}\nNumber of compounds: {len(self.data)}'

    @property
    def timestamp(self):
        return self._timestamp

    @property
    def x(self):
        return self._x

    @x.setter
    def x(self, i):
        self._x = i

    @property
    def y(self):
        return self._y

    @y.setter
    def y(self, i):
        self._y = i

    @property
    def save_dir(self):
        return self._save_dir

    @save_dir.setter
    def save_dir(self, i):
        self._save_dir = i

    @property
    def splits(self):
        return self._splits

    @splits.setter
    def splits(self, i):
        self._splits = i

    @property
    def train(self):
        return self._train

    @train.setter
    def train(self, i):
        self._train = i

    @property
    def valid(self):
        return self._valid

    @valid.setter
    def valid(self, i):
        self._valid = i


    @classmethod
    def from_csv(cls, data_path : str,
                 smiles_col : str,
                 targets_col : str,
                 task_id:str):

        """Build a `MolecularGraphDataset` from a csv file using `smiles_cols`, `targets_cols` and `task_id`.

        Arguments
        ------------------------------------------------------------------------------------------------------------

        data_path : str
            A string representing the path to the modeling dataset

        targets_col : str
            A string representing the column of `data` with the target variable.

        smiles_col : str
            A string representing the column of `data` with SMILES.

        process_data : bool
            If True, process the dataset using `MolecularGraphDataset.preprocessing`

        Returns
        ------------------------------------------------------------------------------------------------------------
            Returns a `MolecularGraphDataset` for ready modeling tasks.

        """

        return cls.from_df(pd.read_csv(data_path),
                           smiles_col=smiles_col,
                           targets_col=targets_col,
                           task_id=task_id)

    @classmethod
    def from_df(cls,
                df : pd.DataFrame,
                smiles_col : str,
                targets_col : str,
                task_id:str):

        """Builds a `MolecularGraphDataset` from a dataframe using `smiles_cols`, `targets_cols` and `task_id`.

        Arguments
        ------------------------------------------------------------------------------------------------------------

            df : DataFrame
                A `pandas.DataFrame` object with the data used for the modeling task.

            targets_col : str
                A string representing the column of `data` with the target variable.

            smiles_col : str
                A string representing the column of `data` with SMILES.

            censored : bool
                If true, removes censored samples from `df`.

        Returns
        ------------------------------------------------------------------------------------------------------------
            Returns a `MolecularGraphDataset` for ready modeling tasks.

        """

        df = df.copy()

        return MolecularGraphDataset(df=df,
                                smiles_col=smiles_col,
                                targets_col=targets_col,
                                     task_id=task_id).create_dataset()


    def create_dataset(self, splitter : Iterator=None, random_state: int = None, test_size: float = 0.2):

        """Creates a dataset for modeling applying featurization and splitting the data into train and test sets.

        Arguments
        ------------------------------------------------------------------------------------------------------------

            splitter : Splitter
                A class or function that returns splits of the data. Default: TrainTestSplitter.

            random_state : int
                A number for random seed.

            test_size : float
                The amount of data used as test set.

        Returns
        ------------------------------------------------------------------------------------------------------------
            Returns a `MolecularGraphDataset` with train/test splits, calculated features and targets.
        """

        # Create Train/Valid datasets
        stratify = self.y if self.job_type in ['classification','multiclass'] else None
        splitter = splitter if splitter else TrainTestSplitter(test_size=test_size, random_state=random_state,stratify=stratify)
        setattr(splitter,'random_state', random_state)
        setattr(splitter, 'test_size', test_size)
        self.splits = splitter(self.data)

        self.train = MolecularGraphDataset(df=self.df.iloc[self.splits[0]].reset_index(drop=True),
                                           smiles_col=self.smiles_col,
                                           targets_col=self.targets_col)

        self.valid = MolecularGraphDataset(df=self.df.iloc[self.splits[1]].reset_index(drop=True),
                                           smiles_col=self.smiles_col,
                                           targets_col=self.targets_col)

        self.train.max_nodes = self.max_nodes
        self.valid.max_nodes = self.max_nodes

        # Save files
        save_df(self.train.df, self.save_dir/f'{self.task_id}_{self.job_type}_{self.timestamp.date()}_trainset.csv')
        save_df(self.df, self.save_dir/f'{self.task_id}_{self.job_type}_{self.timestamp.date()}_dataset_full.csv')
        save_df(self.valid.df, self.save_dir/f'{self.task_id}_{self.job_type}_{self.timestamp.date()}_testset.csv')

        return self

    def __getitem__(self, i):

        """Featurize dataset and optionally updates splits features"""

        graph = MolecularGraph(*self.data[i]).mol_to_graph(max_nodes=self.max_nodes)
        return (graph.node_features, graph.edge_features, graph.adjacency_matrix_norm, graph.degree_matrix), graph.y

        return self